Braced XML
<f>{for (i <- []) <br/>}</f>
stdout : <f/> : XML

Escaped braces
<p>A left: \{ and a right: }</p>
stdout : <p>A left: { and a right: }</p> : XML

Backslashes
<p>A backslash \ </p>
stdout : <p>A backslash \ </p> : XML

Top-level-bound XML object
x = for (i <- []) <br/>; <f>{x}</f>
stdout : <f/> : XML

Let-bound XML object
{x = for (i <- []) <br/>; <f>{x}</f>}
stdout : <f/> : XML

Whitespace preservation
<a b="c"> <d/> </a>
stdout : <a b="c"> <d/> </a> : XML

Element splicing [1]
{x = "three"; <a b="c">{enxml(x)}</a>}
stdout : <a b="c">three</a> : XML

Element splicing [2]
{x = "hre"; <a b="c">t{enxml(x)}e</a>}
stdout : <a b="c">three</a> : XML

Attribute splicing [1]
{x = "three"; <a b="{x}"><c/></a>}
stdout : <a b="three"><c/></a> : XML

Attribute splicing [2]
{x = "three"; <a b="a{x}b"><c/></a>}
stdout : <a b="athreeb"><c/></a> : XML

Rejection of incorrectly nested elements
<a><b></a></b>
stderr : @.*
exit : 1

Rejection of incorrectly typed attributes
{x = 3; <a b="{x}"><c/></a>}
stderr : @.*
exit : 1

Rejection of incorrectly typed l:attributes
{x = 3; <a l:href="{x}"><c/></a>}
stderr : @.*
exit : 1

Reject nonsense l:name attributes
<form><input l:name="{1+1}" /></form>
stderr : @.*
exit : 1

Accept okay l:name attributes
<form><input l:name="foo" /></form>
stderr : @.*
exit : 1

Looping in XML quasis
things = [1, 2]; <ul>{for (x <- things) <br/>}</ul>
stdout : <ul><br/><br/></ul> : XML

Amp-encoding (OK)
<xml>&lt;</xml>
stdout : <xml>&lt;</xml> : XML

Amp-encoding (ill-formed XML)
<xml>this & that</xml>
stderr : @.*
exit : 1

Amp-encoding (converting from string)
x = "this & that"; <xml>{enxml(x)}</xml>
stdout : <xml>this &amp; that</xml> : XML

Looping in XML quasis, with multiple content elements.
things = [1, 2];<ul>{for (x <- things) <li>{enxml(string_of_int(x))}</li><li>1</li>}</ul>
stdout : <ul><li>1</li><li>1</li><li>2</li><li>1</li></ul> : XML
