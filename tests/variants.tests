Construction
Foo
stdout : @Foo \(\) : \[Foo:\(\) | [0-9]*\]

Nested Construction
Foo (Bar)
stdout : @Foo Bar \(\) : \[Foo:\[Bar:\(\) | [0-9]*\] | [0-9]*\]

Nested Construction w/o parens
Foo Bar
stdout : @Foo Bar \(\) : \[Foo:\[Bar:\(\) | [0-9]*\] | [0-9]*\]

Nested Construction w/o parens (nary)
This Is A Valid Links Program
stdout : @This Is A Valid Links Program \(\) : \[This:\[Is:\[A:\[Valid:\[Links:\[Program:\(\) | [0-9]*\] | [0-9]*\] | [0-9]*\] | [0-9]*\] | [0-9]*\] | [0-9]*\]

Nested Construction + argument w/o parens (nary)
This Is A Valid Links Program 42
stdout : @This Is A Valid Links Program 42 : \[This:\[Is:\[A:\[Valid:\[Links:\[Program:Int | [0-9]*\] | [0-9]*\] | [0-9]*\] | [0-9]*\] | [0-9]*\] | [0-9]*\]

Trivial closed case
fun (x) { switch x { A b -> b } }
stdout : @..*
exit : 0

Variant matching - Closed case, immediate value [1]
switch A 3 { A a -> a B b -> b }
stdout : 3 : Int

Variant matching - Closed case, immediate value [2]
switch B 3 { A a -> a B b -> b}
stdout : 3 : Int

Variant matching - Closed case, immediate value [3]
switch L 3 { L x -> x M y -> y}
stdout : 3 : Int

Variant matching - Closed case in function [1]
fun (f) { switch f { A a -> not(a) B b -> b} }
stdout : @fun : .*A:Bool.*B:Bool.* -> Bool

Variant matching - Closed case in function [2]
fun (f) { switch f { A a -> not(a) B b -> true } }
stdout : @fun : .*A:Bool.*B:a.* -> Bool

Variant matching - Closed case in function [3]
fun (f) { switch f { B a -> not(a) A b -> b} }
stdout : @fun : .*A:Bool.*B:Bool.* -> Bool

Variant matching : Closed case type error
fun () { switch C 3 { A a -> a B b -> b} }
stderr : @..*
exit : 1

Variant matching - Open case "immediate value" [1]
switch A true { A a -> a B b -> b c -> false}
stdout : true : Bool

Variant matching - Open case "immediate value" [2]
switch C true { A a -> a B b -> b c -> false }
stdout : false : Bool

Variant matching - Open case in function
fun (f) { switch f { A a -> a B b -> b c -> false } }
stdout : @fun : .*A:Bool.*B:Bool.* -> Bool

Recursive variant types [1]
fun (x) { switch x { A a -> a y -> x } }
stdout : @fun : \(mu [a-z]+ \. \[A:[a-z]+ | [a-z0-9]+\]\)-> mu [a-z]+ \. \[A:[a-z]+ | [a-z0-9]+\]

Recursive variant types [2]
fun increment(x) { switch x { Zero -> Succ (Zero) Succ n -> Succ (increment(n))}}
stdout : @fun : \(mu [a-z]+ \. \[Succ:[a-z]+ | Zero:\(\)\]\) -> \[Zero:\(\) | mu [0-9]+ \. Succ:\[Zero:\(\) | [0-9]+\] | [0-9]+\]

Recursive variant types [3]
fun rev(x, r) { switch x { Empty -> r Cons(a, b) -> rev(b, Cons(a, r)) }}
stdout : @fun : \(mu [a-z]+ \. \[Cons:\([a-z]+, [a-z]+\) | Empty:\(\)\], mu [a-z]+ \. \[Cons:\([a-z]+, [a-z]+\) | [0-9]+\]\) -> mu [a-z]+ \. \[Cons:\([a-z]+, [a-z]+\) | [0-9]+\]

Recursive variant types [4]
fun increment(x) { switch x { Zero -> Succ (Zero) Succ n -> Succ (increment(n))}} increment(Zero)
stdout : @UNKNOWN

Rows preserved across functions
fun f(x) { switch x { Foo -> (Bar) s -> s } }
stdout : @fun : \(\[Bar:\(\) | Foo:\(\) | [0-9]*\]\) -> \[Bar:\(\) | [0-9]*\]

Nullary variants with cases
switch None { None -> None Some x -> Some x }
stdout : None () : [None:() | Some:a | 31]
