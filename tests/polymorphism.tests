Let polymorphism
{fun pair(x) { (x, x) } (pair('a'), pair(13))}
stdout : @\(\('a', 'a'\), \(13, 13\)\) : .*

Monomorphic lambda bindings
(fun (p) -> (p('a'), p(13)))(fun (x) -> (x,x))
stderr : @.
exit : 1

No polymorphic recursion
fun f(x) { if x then f(false) else f("true") }
stderr : @.
exit : 1

No polymorphic recursion (mutually recursive functions)
fun f(x) { a = g(3); b = g("four"); 3 } fun g(x) { a = f(1); 2  } 
stderr : @.
exit : 1

Polymorphic functions
fun cons(x,l) {[x] ++ l}; (cons(5, [6]), cons("a", ["b"]))
stdout : @\(\[5, 6\], \["a", "b"\]\) : \(\[Int\], \[String\]\)

Polymorphic functions in different function bodies
fun cons(x,l) {[x] ++ l}; fun f() { cons(5, [6]) }; fun g() { cons("a", ["b"]) }; (f(), g())
stdout : ([5, 6], ["a", "b"]) : ([Int], [String])

Polymorphic functions in different function bodies (not in call order)
fun f() { cons(5, [6]) }; fun cons(x,l) {[x] ++ l}; fun g() { cons("a", ["b"]) }; (f(), g())
stdout : ([5, 6], ["a", "b"]) : ([Int], [String])
