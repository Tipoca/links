Let polymorphism [1]
fun pair(x) { (x, x) } (pair('a'), pair(13))
stdout : @\(\('a', 'a'\), \(13, 13\)\) : .*

Let polymorphism [2]
{fun pair(x) { (x, x) } (pair('a'), pair(13))}
stdout : @\(\('a', 'a'\), \(13, 13\)\) : .*

Monomorphic lambda bindings
(fun (p) { (p('a'), p(13))})(fun (x) { (x,x) })
stderr : @..*
exit : 1

No polymorphic recursion without signatures
fun f(x) { f("a"); f(1); 1}
stderr : @..*
exit : 1

Polymorphic recursion with signatures
sig f : a -> Int fun f(x) { f("a"); f(1); 1 }
stdout : @fun : \([a-z]\) -> Int

Invalid "polymorphic recursion"
sig f : a -> Int fun f(x) { x == 1; f("a"); f(1); 1 }
stderr : @..*
exit : 1

Polymorphic mutual recursion [1]
sig f : a -> Int fun f(x) { g("a"); g(1); 1 } sig g : a -> Int fun g(x) { f("a"); f(1); 1 }
stdout : @fun : \([a-z]\) -> Int

Polymorphic mutual recursion [2]
sig f : a -> Int fun f(x) { f("a"); g(1); 1 } sig g : a -> Int fun g(x) { g("a"); f(1); 1 }
stdout : @fun : \([a-z]\) -> Int

Polymorphic mutual recursion [3]
sig f : a -> Int fun f(x) { f("a"); f(1); g("a"); g(1); 1 } sig g : a -> Int fun g(x) { f("a"); f(1); g("a"); g(1); 1 } 
stdout : @fun : \([a-z]\) -> Int

Polymorphic mutual recursion [4]
sig f : a -> Int fun f(x) { g("a"); g(1); 1 } sig g : a -> Int fun g(x) { x == 1; f("a"); f(1); 1 }
stderr : @..*
exit : 1

Polymorphic row recursion
sig h : ({a}) ->  Int fun h(x) {h((x,x))}
stdout : @fun : \(|[a-z]+\) -> Int

Polymorphic functions
fun cons(x,l) {[x] ++ l} (cons(5, [6]), cons("a", ["b"]))
stdout : @\(\[5, 6\], \["a", "b"\]\) : \(\[Int\], \[String\]\)

Polymorphic functions in different function bodies
fun cons(x,l) {[x] ++ l} fun f() { cons(5, [6]) } fun g() { cons("a", ["b"]) } (f(), g())
stdout : ([5, 6], ["a", "b"]) : ([Int], [String])

Polymorphic functions in different function bodies (not in call order)
fun f() { cons(5, [6]) } fun cons(x,l) {[x] ++ l} fun g() { cons("a", ["b"]) } (f(), g())
stdout : ([5, 6], ["a", "b"]) : ([Int], [String])

Signatures on top-level variables
sig x : Int var x = 3
stdout : 3 : Int
