BUGS

* There is no way to add an external stylesheet to the doc produced by
  a Links program.
  Proposal: Generate as much of the page as possible on the server, 
  before serving it to the browser. This should include at least the 
  <head>.

* JSON infinitely loops on XML objects (and others, e.g. events)

* Some demos and comments in the code refer to l:action.
  The code now uses l:onsubmit instead.

* .cache files are written right alongside the .cgi script, a location
  which typically won't be writable (webservers writing to the CGI dir
  is often seen as a security hole).

* Trailing final semicolon is not allowed

* JavaScript generation assumes that jslib.js and json.js are
  alongside the generated program; in /cgi-bin/ they won't be
  executable, and hence not accessible. We need to be able control how
  they are located.

* A bare loop variable is not rewritten in a loop body:

      for x <- (...) in
        for y <- (...) in
          [(x, y)]

  fails at rt with "Undefined variable y". Only projects (like 
  y.field) work

* A lot of code takes care with bindings, but ignores l:name bindings.
  (is there a test case here?)

* Partial applications of primitive functions are not serialized
  correctly. (Can we have a test case?)

* "insert into ..." seems to fail if some value is the empty string
  (eekc: I'm not observing this (on MacOS) as of 10 Feb 06; maybe it 
  was shaken out?)

* Syntax for type of a record is subtly different from syntax for a
  record value.
  (jdy: how is this a bug?)
  (eekc: maybe it's a to-do! I just don't like it... what do you think?)

* Database does not report certain errors (e.g., inserting into
  non-existent table is allowed)

* Queries against distinct databases would be joined, yielding a
  broken query.

* Wrong arg-type error messages are misleading. Given 

      fun foo(f, x) { ... }

  the application foo(add) produces:

      `add ' has type (Int, Int) -> Int and cannot be passed as an argument to 
      `foo ', which has type ((Int, a) -> b, a) -> b

  It's bad because add *can* be passed as an arg to foo, we're just missing 
  the second arg.

* Getting the web request into the library layer is HACKed
  ugly. Instead we should create a real value that represents the
  request and force you to pass it around in the language. (?)

* Type errors don't always give the (right) line number.

* There's no check that order fields are present in the table.
  The following ought to be rejected:
     Table "foo" with { a : String } order [ b : asc ] from db

TODO

* Why do we bother to write name="..." as l:name="..." ? Couldn't we
  just create variables for all named input fields?

* Add XML attributes as first-class values (to enable code like this:)
    <option value="1" {if (selected) [ `(selected="SELECTED") ] else []}>
  (eekc: Maybe these should be implemented as Variants? e.g.)
    <option value="1" {if (selected) [Selected "SELECTED"] else []}>

* CDATA literals are not handled in XML quasis.

* XML amp-encoding is only aware of basic entities (&amp; and
  &lt;). See [1] for a full list in DTD form. We should probably just
  import DTDs.

  [1] http://www.w3.org/TR/2002/REC-xhtml1-20020801/dtds.html#a_dtd_Latin-1_characters

* Split Char & Byte types, choose an internal Unicode representation

* XML amp-encoding should support numeric unicode entities. In what
  encoding do we output XML? Do we always use entities for non-ASCII
  characters? The XML spec says:

  "In the absence of information provided by an external transport
  protocol (e.g. HTTP or MIME), it is an error for an entity including
  an encoding declaration to be presented to the XML processor in an
  encoding other than that named in the declaration, for an encoding
  declaration to occur other than at the beginning of an external
  entity, or for an entity which begins with neither a Byte Order Mark
  nor an encoding declaration to use an encoding other than
  UTF-8. Note that since ASCII is a subset of UTF-8, ordinary ASCII
  entities do not strictly need an encoding declaration."
  <http://www.w3.org/TR/1998/REC-xml-19980210#charencoding>

* Instead of this twice-binding Record_selection construct, let's have
  simple projection operations: Record_projection(x, a) has as value
  the field `a' of x, and Record_removal(x, a) has a record value: all
  the fields of x except the field labelled a. Neither one binds.

* Attributes of an XML node are mixed together with contents--could
  cause trouble.
  (Could someone clarify this?)
  (Yes! This is in the interpreter, when it's evaluating the XMLCont
   instruction. It is written so that either an attr or a content 
   element can pop out at any time. This is weird. I think it's 
   related to the problem that an attribute (as a name-value pair) 
   cannot be a value in Links)
  
* Given a function "foo" from a module "moo", I want 

    url_of(moo:foo, [args])

  To return a URL which would act as the invocation of that function
  on those args.

* Automatically inject any value into the XML type when used w/in a
  quasiquote.

* Deal with unnaturalness of [XML] flattening in XML construction and
  [Char] getting boxed as XML Text Node (Could we have an example?
  What's unnatural?)

* No way to access CGI query variables at the Links toplevel.

* postgres dependency lingers, in the form of the get_database
  parameter passed to the deserialization functions. An idea to remove
  it: give every type a "reanimator" function, dual to Java's
  finalizers; the reanimator function T_r for a type T is run when an
  object of that type is deserialized and put into a
  program-to-be-run.

* Erlang backend: compile Links to Erlang.

* Default to Content-type: text/xml+html (Ezra)
  Are Links programs by default XHTML Transitional or Strict?

* Should be able to treat a form post as a record, in addition to
  treating its fields as free variables.

* Ability to do a redirect to a Links continuation or arbitrary URL.

* Cookies, status codes.

* Ability to read/send arbitrary HTTP request/response headers.

* XQuery database implementations

* Pluggable lightweight persistent data

* A way to create db interfaces in Links-space
  -- foreign function interface
  -- arbitrary socket primitives?
  -- "binary" objects as primitive data types (a la Erlang)

* Implicit conversions between Int <-> String to support easy HTML.
  (jdy: Every language I know that does this gets it badly wrong.
   Examples:
     Javascript: "2" + 3 = "23"; "2" * 3 = 6
     Java: + is no longer associative:
           ("2" + (3 + 4)) == "27"
           (("2" + 3) + 4) == "234".
     Perl: "one" + "one" == 0
     C:  "24" + 1 == "4"      // ;-)
     etc.     
   At the moment, I'm pretty convinced that this is the wrong thing to
   do.  We do need something nicer than string_of_int, though.)
  (eekc: I didn't mean supporting arithmetic on decimal strings. I
         just meant that if I use    {my_age} in an XML quasiquote, 
         it ought to just promote the int to a string. Why not?)
  (jdy: ah, ok: Int -> String, not the other way.
         I agree that this would be useful (essential, even), but I
         think we need something like typeclasses to do it while 
         retaining/introducing sanity in the type system)
  (eekc: Some form of typewise dispatch is absolutely necessary, imho;
         maybe type classes, maybe something else.)

* Ability to import values from another file (module system? #include?)
  (jdy: we have this.  namespace n = "file://other-file.links")

* Tests for the web-interface logic

* Think about tuples vs. records: syntax and representation. Unify
  them? Distinctly separate them?

* More unit tests for JavaScript generation.

* Unit tests for everything.

* XML unicode character literals  (e.g. &#318; and &#xD7E8;).

* Find a way to import tables' types from the DDL, or export DDL from 
  table-type declarations

* Handle non-inline Table values.
