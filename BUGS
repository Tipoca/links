BUGS

* Returning a seq'ce of XML items at the toplevel gives "ASSERTION FAILED:
  Top-level expression was not XML"

* Event objects get their fields blanked out if you pass them to another 
  process or yield while handling the event. Need to clone the object?

* Comparison of variants is always false in JS target.

* There is no way to add an external stylesheet to the doc produced by
  a Links program.
  Proposal: Generate as much of the page as possible on the server, 
  before serving it to the browser. This should include at least the 
  <head>.

* JSON infinitely loops on XML objects (and others, e.g. events)

* Some demos and comments in the code refer to l:action.
  The code now uses l:onsubmit instead.

* .cache files are written right alongside the .cgi script, a location
  which typically won't be writable (webservers writing to the CGI dir
  is often seen as a security hole).

* JavaScript generation assumes that jslib.js and json.js are
  alongside the generated program; in /cgi-bin/ they won't be
  executable, and hence not accessible. We need to be able control how
  they are located.

* A bare loop variable is not rewritten in a loop body:

      for (var x <- (...))
        for (var y <- (...))
          [(x, y)]

  fails at rt with "Undefined variable y". Only projects (like 
  y.field) work

* A lot of code (for example, Syntax.freevars) takes care with
  bindings, but ignores l:name bindings.  See Webif.is_client_program
  for an example of this causing problems.

* Partial applications of primitive functions are not serialized
  correctly. (Can we have a test case?)

* Syntax for type of a record is subtly different from syntax for a
  record value.
  (jdy: how is this a bug?)
  (eekc: maybe it's a to-do! I just don't like it... what do you think?)

* Database does not report certain errors (e.g., inserting into
  non-existent table is allowed)

* Queries against distinct databases would be joined, yielding a
  broken query.

* Wrong arg-type error messages are misleading. Given 

      fun foo(f, x) { ... }

  the application foo(add) produces:

      `add ' has type (Int, Int) -> Int and cannot be passed as an argument to 
      `foo ', which has type ((Int, a) -> b, a) -> b

  It's bad because add *can* be passed as an arg to foo, we're just missing 
  the second arg.

* Getting the web request into the library layer is HACKed
  ugly. Instead we should create a real value that represents the
  request and force you to pass it around in the language. (?)

* The following planned DOM ops are unimplemented as yet:
  domGetFirstChildRef, domGetNextSiblingRef, domGetPrevSiblingRef

TODO

* It'd be more symmetric to allow arbitrary let-patterns (rather than
  just variable and function bindings) at top level.  For example,

       links> var (x,y) = (1,2);;

* We should decide on the right semantics for type annotations.  What
  should we do in each of these cases, for example?:

       fun (x) { x + 1 } : a -> a
       fun (x) { x } : Int -> Int
       fun (x) { x : a } : (a -> a) -> (a -> a)
       fun (x) { x : a } : a

* It'd be nice if the type variable names in annotations were
  preserved.  That is, instead of this

       links> fun (x) { x } : c -> c;;
       fun : (a) -> a

  we'd have this:

       links> fun (x) { x } : c -> c;;
       fun : (c) -> c

* We should take into account whether we're printing mailbox types
  when assigning type variables.  That is, instead of this

       links> fun (x) { x } ;;
       fun : (b) -> b

  we'd have this:

       links> fun (x) { x } ;;
       fun : (a) -> a

* We need UI methods for the position relative to the target, and
  rel. to the screen. Also: how about eventGetPageXY, to return an
  (x, y) pair?

* getTextContent(xml) only works for text nodes. We should have
  something that gets the doc-order concatenation of all the text-node
  descendents of some xml; it should work for forests as well as
  trees.

* Why do we bother to write name="..." as l:name="..." ? Couldn't we
  just create variables for all named input fields?

* Add XML attributes as first-class values (to enable code like this:)
    <option value="1" {if (selected) [ `(selected="SELECTED") ] else []}>
  (eekc: Maybe these should be implemented as Variants? e.g.)
    <option value="1" {if (selected) [Selected ("SELECTED")] else []}>

* CDATA literals are not handled in XML quasis.

* XML amp-encoding is only aware of basic entities (&amp; and
  &lt;). See [1] for a full list in DTD form. We should probably just
  import DTDs.

  [1] http://www.w3.org/TR/2002/REC-xhtml1-20020801/dtds.html#a_dtd_Latin-1_characters

* Split Char & Byte types, choose an internal Unicode representation

* XML amp-encoding should support numeric unicode entities. In what
  encoding do we output XML? Do we always use entities for non-ASCII
  characters? The XML spec says:

  "In the absence of information provided by an external transport
  protocol (e.g. HTTP or MIME), it is an error for an entity including
  an encoding declaration to be presented to the XML processor in an
  encoding other than that named in the declaration, for an encoding
  declaration to occur other than at the beginning of an external
  entity, or for an entity which begins with neither a Byte Order Mark
  nor an encoding declaration to use an encoding other than
  UTF-8. Note that since ASCII is a subset of UTF-8, ordinary ASCII
  entities do not strictly need an encoding declaration."
  <http://www.w3.org/TR/1998/REC-xml-19980210#charencoding>

* Instead of this twice-binding Record_selection construct, let's have
  simple projection operations: Record_projection(x, a) has as value
  the field `a' of x, and Record_removal(x, a) has a record value: all
  the fields of x except the field labelled a. Neither one binds.

* Attributes of an XML node are mixed together with contents--could
  cause trouble.
  (Could someone clarify this?)
  (Yes! This is in the interpreter, when it's evaluating the XMLCont
   instruction. It is written so that either an attr or a content 
   element can pop out at any time. This is weird. I think it's 
   related to the problem that an attribute (as a name-value pair) 
   cannot be a value in Links)
  
* Given a function "foo" from a module "moo", I want 

    url_of(moo:foo, [args])

  To return a URL which would act as the invocation of that function
  on those args.

* Automatically inject any value into the XML type when used w/in a
  quasiquote.

* Deal with unnaturalness of [XML] flattening in XML construction and
  [Char] getting boxed as XML Text Node (Could we have an example?
  What's unnatural?)

* No way to access CGI query variables at the Links toplevel.

* Default to Content-type: text/xml+html (Ezra)
  Are Links programs by default XHTML Transitional or Strict?

* Should be able to treat a form post as a record, in addition to
  treating its fields as free variables.

* Ability to do a redirect to a Links continuation or arbitrary URL.

* Cookies, status codes.

* Ability to read/send arbitrary HTTP request/response headers.

* XQuery database implementations

* Pluggable lightweight persistent data

* A way to create db interfaces in Links-space
  -- foreign function interface
  -- arbitrary socket primitives?
  -- "binary" objects as primitive data types (a la Erlang)

* Implicit conversions between Int <-> String to support easy HTML.
  (jdy: Every language I know that does this gets it badly wrong.
   Examples:
     Javascript: "2" + 3 = "23"; "2" * 3 = 6
     Java: + is no longer associative:
           ("2" + (3 + 4)) == "27"
           (("2" + 3) + 4) == "234".
     Perl: "one" + "one" == 0
     C:  "24" + 1 == "4"      // ;-)
     etc.     
   At the moment, I'm pretty convinced that this is the wrong thing to
   do.  We do need something nicer than string_of_int, though.)
  (eekc: I didn't mean supporting arithmetic on decimal strings. I
         just meant that if I use    {my_age} in an XML quasiquote, 
         it ought to just promote the int to a string. Why not?)
  (jdy: ah, ok: Int -> String, not the other way.
         I agree that this would be useful (essential, even), but I
         think we need something like typeclasses to do it while 
         retaining/introducing sanity in the type system)
  (eekc: Some form of typewise dispatch is absolutely necessary, imho;
         maybe type classes, maybe something else.)

* Ability to import values from another file (module system? #include?)

* Tests for the web-interface logic

* Think about tuples vs. records: syntax and representation. Unify
  them? Distinctly separate them?

* More unit tests for JavaScript generation.

* Unit tests for everything.

* XML unicode character literals  (e.g. &#318; and &#xD7E8;).

* Find a way to import tables' types from the DDL, or export DDL from 
  table-type declarations
