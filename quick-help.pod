=pod

=head1 Links Syntax

=head2 Comments

Comments are introduced by a hash mark, C<#>, and continue for the
rest of the line.

=head2 Literals

Numbers: C<2>, C<7>, C<14.5>.

Booleans: C<true>, C<false>.

Strings: C<"Twain">, C<"\"I've dropped the toothpaste,\" Tom said,
crestfallen.">.

Characters: C<'a'>, C<'9'>, C<'\012'>.

=head2 Pairs, Tuples, and Records

A tuple is a finite sequence of values, possibly of different
types. An n-tuple is constructed by enclosing n expressions in
parenthesis and separating them with commas:

   (a, "OK")
   
   (7)
   
   (true, "a string", 42)

A 1-tuple is distinct from the value it contains (FIXME: is this
true?) but this rarely occurs in practice.

TBD: talk about records.

=head2 Variants

TBD: talk about variants.

=head2 XML Quasiquotes

Also called "quasis." Introduced by an XML start-tag such as
C<E<lt>fooE<gt>>. Inside a quasi, Links code enclosed within braces 
{ } will be evaluated to an XML forest and include, when the quasi 
is evaluated.

    <html>
      <ul>
        <li> First item: {item1} </li>
        <li> Second item: {item2} </li>
      </ul>
    </html>

Within an XML quasi, a variety of special features can be used to
handle browser events. See L<Handling Browser Events>, below, for more
information on these features.

=head2 Comparisons and Boolean Expressions

Comparisons are binary operations that yield a true/false value. 

=over 4

=item * ==

True iff the operands evaluate to the same value.

=item * <>

True iff the operands evaluate to different values.

=item * <<

True iff the left operand's value is less than the right operand's
(only valid on numbers (?))

=item * >>

True iff the right operand's value is less than the left operand's
(only valid on numbers (?))

=item * <=

True iff the left operand's value is less than or equal to the right
operand's (only valid on numbers (?))

=item * >=

True iff the right operand's value is less than or equal to the left
operand's (only valid on numbers (?))

=back

Boolean expressions can be combined using the boolean operators:

=over 4

=item * &&

=item * ||

=item * !

=back

=head2 Conditionals

A conditional expression has a condition, a consequent, and an else
clause. None of the three may be omitted.

    if (x == y)
        do_something()
    else
        do_something_else()

Curly braces can be wrapped either clause, no matter how many
sub-expressions they contain, and I<must> be so wrapped if you want
the clause to consist of more than one semicolon-separated expression.

Note that an C<if>-C<else> expression I<always> returns a value in
Links; the return values of the two branches must be of the same type,
and both branches are required.

=head2 Variables

Variables are single-assignment in Links. The form

    x = expr;
    etc

evaluates C<expr> and binds the name C<x> to the resulting value,
within the expression C<etc>.

Variable assignments have block scope. The following example

    x = 1;
    if (condition) {
      x = 2
    } else {
      x = 3
    };
    print int_to_string(x);

prints C<1> because the assignments to C<x> within the if clauses only
bind within those clauses. If you want the value printed to depend on
the condition, you should assign to C<x> from the result of the whole
C<if> expression:

    x = if (condition) {
      x = 2
    } else {
      x = 3
    };
    print int_to_string(x);

=head2 Blocks

A sequence of assignments separated by semicolons is evaluated in
turn, binding each value to the corresponding name in what
follows. Variables are assigned only once per scope, and succeeding
assignments will mask preceding ones:

    x = 1;
    y = 2;
    x = 2;
    z = x + y;    # z is now bound to 4

The scope of an assignment is strictly within its immediate
block. Thus in this expression:

    x = 0;
    if (a == b)
        x = 1;
    else
        x = 2;
    alert(x);

The value printed by C<alert> will be 0. That's because the other two
assignments only create new bindings for x within the corresponding
clauses of the conditional. This may come as a surprise to programmers
from some languages.

=head2 Collections: Bags, Sets, and Lists

TBD: remove bags and sets.

A list is a finite sequence of values. A list can be created by
wrapping a series of expressions in brackets:

    [1, 4, 9, 16]
    
    ["apple", "banana", "pear"]

    x = true;
    [true, false, x, true]

Note that all elements of a list must be of the same type.

Lists support the "concatenate" operation, denoted by two plus
characters:

    [1, 2] ++ [3, 4, 5] == [1, 2, 3, 4, 5]

TBD: Talk about bags, lists.

=head2 Functions

Functions can be named or anonymous. Named functions look like

    fun foo(x, y, z)
    {
        # ... body 
    }

Anonymous functions just omit the name: C<fun (x) { x + 1 }> is an
expression that evaluates to an anonymous function value.

Function values, whether named or anonymous, are lexical closures; any
variables free in the body must refer to bindings from a surrounding
lexical scope. The smallest surrounding scope is chosen.

A function can be called by using its name, followed by a list of
arguments in parentheses:

    foo(1, 2, 7)

This works whether C<foo> is a function defined with a name, as C<fun
foo(...) {...}>, or a variable bound to a functional value, as

    inc = fun (x) {x + 1};
    inc(7)

This block returns C<8>.

=head2 Loops (List Comprehensions)

The principal loop construct in Links is the list comprehension:

    for (x <- source)
       body

The body should be an expression that evaluates to a bag, set, or
list.

A comprehension produces a list which is the concatenation of all the
collections produced by evaluating the body, once for each element of
source, and binding that element to the name C<x>. For example:

    source_list = [1, 2, 3];
    for (n <- source_list)
        [ n*n ]

constructs a list of the squares of the values in C<source_list>. Note
that more than one value can be included in the body list:

    source_list = [2, 3, 7, 8, 9, 55];
    for (n <- source_list)
        if (odd(n))
           [n, n+1]
        else
           [n]

This example returns C<[2, 3, 4, 7, 8, 8, 9, 10, 55, 56]>.

And of course, any expression is valid as the body, as long as its
type is a collection type.

Other forms of looping can be implemented using tail recursion.

=head2 Spawning Processes

... TBD: describe spawn ...

=head2 Message Passing

... TBD: describe message passing ...

=head1 Features

=head2 Handling Browser Events

A Links program usually runs on a client (browser) and a server. The
client code can be notified when certain user events take place, such
as pressing a key on the keyboard or clicking on a hyperlink. The code
that responds to such events is associated with particular nodes in
the DOM tree and is expressed through special XML attributes, called
l-event attributes, attached to the relevant XHTML tags. This section
defines the attributes and their use.

An l-event attribute begins with the prefix C<l:> and corresponds to
an event type as defined by the browser. The event type is determined
by the attribute name simply by stripping off the C<l:>
prefix. Widely-supported l-event attributes include:

=over 4 

=item * C<l:onmousedown>

=item * C<l:onmouseup>

=item * C<l:onkeyup>

=item * C<l:onkeydown>

=item * C<l:onclick>

=item * C<l:onfocus>

=item * C<l:onchange>

=item * C<l:onload>

=back

When an element containing one of these attributes is installed in the
current DOM document (see L<Modifying the DOM>), the associated code
is registered as a handler for the corresponding event type. If the
element is removed from the DOM, its event handlers become inactive.

The content of one of these attributes should be a Links expression
enclosed in braces C<{E<nbsp>}>, an expression of type unit (?) which
may perform side-effects in response to the event. For example:

    <input type="button" value="Add Photo"
           l:onclick="{dom ! AppendChild({id = "container",
                                          node = <img src="..."/>})}" />


=head3 Interpreting the Event

A variable C<event> is always in scope for l-event code; the value of
this variable is a record corresponding to the event object passed by
the browser: it contains a field for each data member of the browser's
object. (TBD: give refs for IE, Mozilla docs) (NOTE: this is not
well-defined; need to use functional wrapper.)

=head2 Modifying the DOM

L<XML Quasiquote|XML Quasiquotes> expressions construct XML values;
but these values are not rendered by a browser until they are
I<installed> in the I<active document>.

There are two ways to modify the active document:

=over 4

=item 1.
A value returned by the final expression of a Links program is
installed as the (initial) active document.

=item 2.
Messages sent to the special process C<dom> can modify the active
document.

=back

Elements that are not installed are not visible, nor do events occur
on them, so their event handlers cannot fire.

=head2 The C<dom> Process

The C<dom> process handles a suite of messages, as follows (TBD: iron
this out):

=over 4

=item * C<ReplaceElement({id = nodeId, replacement = elem})>

Replaces the element with ID C<nodeId> in the active document with the
element elem.

=item * C<AppendChild({id = parentId, replacement = elem})>

Appends C<elem> to the list of children of the element with ID
C<parentId> in the active document.

=item * C<SwapNode({first = elem1, second = elem2})>

Moves C<elem1> to the location in the active document occupied by
C<elem2> and vice versa.

=item * Document(newDocument)

Replaces the entire active document with C<newDocument>.

=back


=cut

