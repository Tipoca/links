=pod

=head1 Links Syntax

=head2 Comments

Comments are introduced by a hash mark, C<#>, and continue for the
rest of the line.

=head2 Literals

Numbers: C<2>, C<7>, C<14.5>.

Booleans: C<true>, C<false>.

Strings: C<"Cappuccino">, C<"\"I've dropped the toothpaste,\" Tom said,
crestfallen.">.

Characters: C<'a'>, C<'9'>, C<'\012'>.

=head2 Pairs, Tuples, and Records

A tuple is a finite sequence of values, possibly of different
types. An n-tuple is constructed by enclosing n expressions in
parenthesis and separating them with commas:

   (a, "OK")
   (true, "a string", 42)

TBD: talk about records.

=head2 Variants

A "Variant type" is one that uses a set of tags to differentiate
values as to what they mean. For example, a mode of transport may be
either Automobile or Camel. If it is Automobile, we want to know what
fuel it takes; if it is Camel, we want to know how many humps it
has. In Links, values like these can be expressed as follows:

  Automobile Diesel
  Automobile Unleaded
  Camel 2

The I<type> that includes such values is written as follows:

  [|Automobile [|Diesel | Unleaded | Biodiesel|] | Camel Int |]

The boxy brackets C<[| |]> delimit a variant type, and variant labels
are separated by a pipe C<|>. After each variant label is the type of
its contents--a Camel has a number of humps so its content type is
C<Int>, whereas the Automobile content type is another variant type,
C<[|Diesel | Unleaded|]>.

In Links, I<a variant tag always begins with a capital letter>. Any
string beginning with a capital letter, used in a value context,
denotes a variant label.

To use a variant, use pattern matching. Pattern matching is
accomplished using the C<switch> form, which has a target expression
and a case for each variant label. The following expression determines
the effective number of humps of a transport (autos have no humps):

  switch target {
    case Automobile fuelType -> 0;
    case Camel humpCount -> humpCount;
  }

The expression C<expr> is evaluated to produce a value of variant
type; then the label is examined and one of the cases is chosen. The
lowercase word following the variant label in a case is bound to the
content of the target value (provided that case actually matches the
target). This allows us to use the variable C<humpCount> within the
body of the C<Camel> case. The body of a case (everything between the
C<-E<gt>> and the C<;>) produces the result of the whole switch
expression, and all case bodies of a switch must have the same type.

Type-checking will also ensure that all possible cases are matched by
the C<switch> expression. To handle arbitrary variant values, you can
add an open case to the end of the switch:

  switch target {
    case Automobile fuelType -> 0;
    case Camel humpCount -> humpCount;
    case other -> 0;
  }

Since C<other> begins with a lowercase letter, it is a variable, which
matches any value. Unlike the variables in the previous cases, which
are wrapped inside variant labels, C<other> is used here as the
complete pattern to match for its case, so it will match
anything. Patterns are tried in the order they are given, so the
C<other> case will not by selected unless the previous cases do not
match.

Here we assume that nothing other than a camel has humps.

=head2 Pattern matching on lists

TBD: talk about pattern matching on lists.

=head2 XML Quasiquotes

Also called "quasis." Introduced by an XML start-tag such as
C<E<lt>fooE<gt>>. Inside a quasi, Links code enclosed within braces 
{ } will be evaluated to an XML forest and include, when the quasi 
is evaluated.

    <html>
      <ul>
        <li> First item: {item1} </li>
        <li> Second item: {item2} </li>
      </ul>
    </html>

Within an XML quasi, a variety of special features can be used to
handle browser events. See L<Handling User Actions>, below, for more
information on these features.

=head2 Comparisons and Boolean Expressions

Comparisons are binary operations that yield a true/false value. 

=over 4

=item * ==

True iff the operands evaluate to the same value.

=item * <>

True iff the operands evaluate to different values.

=item * <<

True iff the left operand's value is less than the right operand's
(only valid on numbers (?))

=item * >>

True iff the right operand's value is less than the left operand's
(only valid on numbers (?))

=item * <=

True iff the left operand's value is less than or equal to the right
operand's (only valid on numbers (?))

=item * >=

True iff the right operand's value is less than or equal to the left
operand's (only valid on numbers (?))

=back

Boolean expressions can be combined using the boolean operators:

=over 4

=item * &&

=item * ||

=item * !

=back

=head2 Conditionals

A conditional expression has a condition, a consequent, and an else
clause. None of the three may be omitted.

    if (x == y)
        expr1
    else
        expr2

Curly braces can be wrapped either clause, no matter how many
sub-expressions they contain, and I<must> be so wrapped if you want
the clause to consist of more than one semicolon-separated expression.

Note that an C<if>-C<else> expression I<always> returns a value in
Links; the return values of the two branches must be of the same type,
and both branches are required.

=head2 Variables

Variables are single-assignment in Links. The form

    x = expr;
    etc

evaluates C<expr> and binds the name C<x> to the resulting value,
within the expression C<etc>.

Variable assignments have block scope. The following example

    x = 1;
    if (condition) {
      x = 2
    } else {
      x = 3
    };
    print int_to_string(x);

prints C<1> because the assignments to C<x> within the if clauses only
bind within those clauses. If you want the value printed to depend on
the condition, you should assign to C<x> from the result of the whole
C<if> expression:

    x = if (condition) {
      x = 2
    } else {
      x = 3
    };
    print int_to_string(x);

=head2 Blocks

A sequence of assignments separated by semicolons is evaluated in
turn, binding each value to the corresponding name in what
follows. Variables are assigned only once per scope, and succeeding
assignments will mask preceding ones:

    x = 1;
    y = 2;
    x = 2;
    z = x + y;    # z is now bound to 4

The scope of an assignment is strictly within its immediate block. As
a result, the following code may not do what you expect:

    x = 0;
    if (a == b)
        x = 1;
    else
        x = 2;
    alert(x);

The value printed by C<alert> will be 0. That's because the other two
assignments only create new bindings for x within the corresponding
clauses of the conditional. This may come as a surprise to programmers
from some languages.

=head2 Lists

A list is a finite sequence of values. A list can be created directly 
by wrapping a series of expressions in brackets:

    [1, 4, 9, 16]
    
    ["apple", "banana", "pear"]

    x = true;
    [true, false, x, true]

Note that all elements of a list must be of the same type.

Lists support the "concatenate" operation, denoted by two plus
characters:

    [1, 2] ++ [3, 4, 5] == [1, 2, 3, 4, 5]

And they're comparable, with C<==>, as you can see!

=head2 Functions

Functions can be named or anonymous. Named functions look like

    fun foo(x, y, z)
    {
        # ... body 
    }

Anonymous functions just omit the name: C<fun (x) { x + 1 }> is an
expression that evaluates to an anonymous function value.

Function values, whether named or anonymous, are lexical closures; any
variables free in the body must refer to bindings from a surrounding
lexical scope. The smallest surrounding scope is chosen.

A function can be called by using its name, followed by a list of
arguments in parentheses:

    foo(1, 2, 7)

This works whether C<foo> is a function defined with a name, as C<fun
foo(...) {...}>, or a variable bound to a functional value, as

    inc = fun (x) {x + 1};
    inc(7)

This block returns C<8>.

=head2 Loops (List Comprehensions)

The principal loop construct in Links is the list comprehension:

    for (x <- source)
       body

The body should be an expression that evaluates to a list.

The value of a comprehension is the concatenation of all the lists
produced by evaluating the body, once for each element of I<source>, and
binding that element to the variable C<x>. For example:

    source_list = [1, 2, 3];
    for (x <- source_list)
        [ x*x ]

constructs a list of the squares of the values in C<source_list>. Note
that more than one value can be included in the body list:

    source_list = [2, 3, 7, 8, 9, 55];
    for (n <- source_list)
        if (odd(n))
           [n, n+1]
        else
           [n]

This example returns C<[2, 3, 4, 7, 8, 8, 9, 10, 55, 56]>.

Other forms of looping can be implemented using tail recursion.

=head1 Features

=head2 Concurrency

A Links program begins as a single thread of control but can fork into
many threads by executing the C<spawn> primitive:

  newThreadID = spawn(func, arg)

This starts a new thread which begins by applying C<func> to the
single argument C<arg>. If the function ever returns, its return value
is discarded. C<spawn> returns an identifier of the new thread to the
calling thread. This identifier can be used to address messages to the
new thread, with the C<send> primitive:

  send(threadID, msg)

This appends the value C<msg> to the mailbox for the thread identified
by C<threadID>. The return value is just C<msg>. The mailbox is FIFO,
so if you know that some message is sent before some other message,
you know they will be received in that order.

Each process's mailbox is given a static type according to the
messages it expects to receive. Typically, a process will use variants
to tag the various messages it can receive; for example, a process
that can expects to be informed of passing comets and celebrity
sightings might expect to receive either a value
C<CelebritySighting(celebName, atVenue)> or a value
C<PassingComet(cometID, zenith, azimuth)>. This process's mailbox
would be given the type 
C<[|CelebritySighting(String, String) | PassingComet(Int, Float, Float)|]>

A process can receive messages using the C<recv> function, which
returns the next message in the current process's mailbox.

  nextMsg = recv()

More commonly, however, you will want to dispatch on the received
message's variant tag immediately. The C<receive> construct makes this
easy to do.

  receive {
    case CelebritySighting(celebName, atVenue) -> e1;
    case PassingComet(cometID, zenith, azimuth) -> e2;
  }

This removes the next message from the mailbox and does a C<switch> on
it. (See L<Variants|Variants>).

=head2 Located code and remote procedure calls

TBD: Describe client/server annotations and RPC calls

=head2 Handling User Actions

A Links program usually runs on a client (browser) and a server. The
client code can be notified when certain user events take place, such
as pressing a key on the keyboard or clicking on a hyperlink. The code
that responds to such events is associated with particular nodes in
the DOM tree and is expressed through special XML attributes, called
l-event attributes, attached to the relevant XHTML tags. This section
defines the attributes and their use.

An l-event attribute begins with the prefix C<l:> and corresponds to
an event type as defined by the browser. The event type is determined
by the attribute name simply by stripping off the C<l:>
prefix. Widely-supported l-event attributes include:

=over 4 

=item * C<l:onmousedown>

=item * C<l:onmouseup>

=item * C<l:onkeyup>

=item * C<l:onkeydown>

=item * C<l:onclick>

=item * C<l:onfocus>

=item * C<l:onchange>

=item * C<l:onload>

=back

(TBD: need to rationalize this list a bit. In keeping with the
C<Event> interface, we need a browser-independent set of event
handlers.)

When an element containing one of these attributes is installed in the
current DOM document (see L<Modifying the DOM>), the associated code
is registered as a handler for the corresponding event type. If the
element is removed from the DOM, its event handlers become inactive.

The content of one of these attributes should be a Links expression
enclosed in braces C<{E<nbsp>}>, an expression of type unit (?) which
may perform side-effects in response to the event. For example:

    <input type="button" value="Add Photo"
           l:onclick="{domAppendChildXml(container,
                                         <img src="..."/>)}" />


=head3 Interpreting the Event

In an l-event handler, there is a special variable in scope called C<event>. 
This variable contains an object of type C<Event> which can be accessed using 
the following API. This API corresponds to the Yahoo! Web UI library (TBD: Add 
ref). These methods are implemented in a browser-independent way. These 
functions constitute the sole interface to the C<Event> object: the object is 
not a record and has no directly-accessible fields.

=over 4

=item C<evtGetTarget>

An event generally has a I<target>, a DOMNodeRef at which the event has 
occurred (for example, a mouse-down event will have as its target the leaf 
node upon which the mouse was clicked). This method returns the target.

=item C<evtGetTargetResolveTextNode>

This method behaves like C<evtGetTarget>, except that if the node is a text 
node (rather than an element node), it returns the node's parent, which must 
be an element node.

(TBD: rename this to C<evtGetTargetElement>)

=item C<evtGetRelatedTarget>

Besides their "target," some events have a I<related target>. For example, a
mouse-out event (TBD: define this) identifies an element which the mouse moved
I<out of> and one which it movedd I<into>.

=item C<evtGetPageX>

=item C<evtGetPageY>

Some events refer to a particular point on the page. These methods return 
the x and y coordinates of that point, relative to the top-left corner of the 
page (I<right> and I<down> are the positive directions).

(TBD: need methods for the position relative to the target, and rel. to the 
screen. Also: how about C<evtGetPageXY> returning an (x, y) pair?)

=item evtGetTime

=back

=head2 Modifying the Page

L<XML Quasiquote|XML Quasiquotes> expressions construct XML values, but these 
values are not rendered by a browser immediately. XML values can be used to 
create DOM nodes, which in turn can be installed in the I<active document>.

There are two ways to install nodes in the active document:

=over 4

=item 1.
An XML value returned by the final expression of a Links program is converted
to a DOM node and installed as the (initial) active document. This is true for 
a server-side program as well as a client/server program. (TBD: explain this 
distinction.)

=item 2.
A set of primitives (beginning with C<dom>-) are provided for making 
modifications to particular parts of the document. These operations only work 
in client context.

=back

Elements that are not installed are not visible, nor do events occur
on them, so their event handlers cannot fire. (See L<Handling User Actions>.)

Links makes a distinction between XML trees, which are immutable,
and DOM nodes, which are mutable objects. DOM nodes are owned by a DOM
manager module, and all interaction with DOM nodes is through calls to
that module, using objects call C<DOMNodeRef>s. You can create DOM
nodes by passing an XML tree: the XML constitutes a model for the DOM
node, which is a rough copy of the XML. Likewise, from a DOMNodeRef,
you can extract an XML image of the DOM node and its DOM subtree. The
browser may have special semantics associated with DOM nodes, and may
add or remove attributes and children without warning; XML values,
however, are completely within the control of the Links program.

=head3 DOM operations

The operations for DOM interaction are as follows. Operations ending with C<Ref>
work on DOM nodes; operations ending with C<Xml> take an XML value and convert
it to a DOM node before working with it.

=over 4

=item C<domInsertBeforeXml(xmlVal, beforeRef)>

Creates a node using C<xmlVal> as the image, and adds it as the previous sibling 
of the node C<beforeRef>.

=item domAppendChildXml(xmlVal, parentRef)

Creates a node using xmlVal as the image, and adds it as the last child of the
node C<parentRef>.

=item C<domRemoveNodeRef(ref)>

Removes C<ref> from its current position, leaving it with no parent. This makes 
it an orphan.

=item C<domInsertBeforeRef(moveRef, beforeRef)>

Moves the node C<moveRef> to become the previous sibling of the node C<beforeRef>.

=item C<domAppendChildRef(newChildRef, parentRef)>

Moves the node C<newChildRef> to become the last child of the node C<parentRef>.

=item C<domGetDocRef()>

Return a reference to the I<document element>, that is, the top-level of the 
installed document.

=item C<domGetRefByID(id)>

Given a string ID value, finds the DOM node with that ID and returns it. If 
more than one node has that ID, the behavior is undefined.

=item C<domGetRepresentation(ref)>

Translates the given DOM node into an XML value and returns that.

=back 

Note: when manipulating the DOM, care should be taken to ensure that a given 
ID value appears only once amongst the installed DOM nodes. Some operations 
may behave unreliably when IDs are duplicated. Orphaned DOM nodes may reuse 
ID values (TBD: is this true?).

You can also access attributes of DOM nodes, and navigate the DOM
tree, in a reado-only fashion using the following operations:

=over 4 

=item domGetTagNameRef(ref)

Returns the tag name of C<ref> as a string. For example, a C<div> node would 
return the string C<"div">.

=item domGetAttributeRef(ref, attrName)

Returns the value of the attribute C<attrName> on the node C<ref>. For example, 
on a node pointed to by C<ref> with the XML representation

  <a href="more_info.html">More info</a>,

the call C<domGetAttributeRef(ref, "href")> would return the string 
C<"more_info.html">.

=item domGetParentNodeRef(ref)

If the node pointed to by C<ref> has a parent, this call returns a reference to 
that parent node.

=back

(TBD: Document XML accessors getTagNameXml, getAttribute, getTextContent, 
getAttributes)

(TBD: We are missing : domGetChildrenRef, getChildren, domGetFirstChildRef, 
domGetNextSiblingRef, domGetPrevSiblingRef)

=head1 Standard Library

TBD: other standard operations.

=cut

