=pod

=head1 Links Syntax

=head2 Comments

Comments are introduced by a hash mark, C<#>, and continue for the
rest of the line.

=head2 Literals

Numbers: C<2>, C<7>, C<14.5>.

Booleans: C<true>, C<false>.

Strings: C<"Twain">, C<"\"I've dropped the toothpaste,\" Tom said,
crestfallen.">.

Characters: C<'a'>, C<'9'>, C<'\012'>.

=head2 Pairs, Tuples, and Records

A tuple is a finite sequence of values, possibly of different
types. An n-tuple is constructed by enclosing n expressions in
parenthesis and separating them with commas:

   (a, "OK")
   
   (7)
   
   (true, "a string", 42)

A 1-tuple is distinct from the value it contains (FIXME: is this
true?) but this rarely occurs in practice.

TBD: talk about records.

=head2 Variants

A "Variant type" is one that uses a set of tags to differentiate
values as to what they mean. For example, a mode of transport may be
either Automobile or Camel. If it is Automobile, we want to know what
fuel it takes; if it is Camel, we want to know how many humps it
has. In Links, values like these can be expressed as follows:

  Automobile Diesel
  Automobile Unleaded
  Camel 2

The I<type> that includes such values is written as follows:

  [|Automobile [|Diesel | Unleaded | Biodiesel|] | Camel Int |]

The boxy brackets C<[| |]> delimit a variant type, and variant labels
are separated by a pipe C<|>. After each variant label is the type of
its contents--a Camel has a number of humps so its content type is
C<Int>, whereas the Automobile content type is another variant type,
C<[|Diesel | Unleaded|]>.

In Links, I<a variant tag always begins with a capital letter>. Any
string beginning with a capital letter, used in a value context,
denotes a variant label.

To use a variant, use pattern matching. Pattern matching is
accomplished using the C<switch> form, which has a target expression
and a case for each variant label. The following expression determines
the effective number of humps of a transport (autos have no humps):

  switch target {
    case Automobile fuelType -> 0;
    case Camel humpCount -> humpCount;
  }

The expression C<expr> is evaluated to produce a value of variant
type; then the label is examined and one of the cases is chosen. The
lowercase word following the variant label in a case is bound to the
content of the target value (provided that case actually matches the
target). This allows us to use the variable C<humpCount> within the
body of the C<Camel> case. The body of a case (everything between the
C<-E<gt>> and the C<;>) produces the result of the whole switch
expression, and all case bodies of a switch must have the same type.

Type-checking will also ensure that all possible cases are matched by
the C<switch> expression. To handle arbitrary variant values, you can
add an open case to the end of the switch:

  switch target {
    case Automobile fuelType -> 0;
    case Camel humpCount -> humpCount;
    case other -> 0;
  }

Since C<other> begins with a lowercase letter, it is a variable, which
matches any value. Unlike the variables in the previous cases, which
are wrapped inside variant labels, C<other> is used here as the
complete pattern to match for its case, so it will match
anything. Patterns are tried in the order they are given, so the
C<other> case will not by selected unless the previous cases do not
match.

Here we assume that nothing other than a camel has humps.

=head2 Pattern matching on lists

TBD: talk about pattern matching on lists.

=head2 XML Quasiquotes

Also called "quasis." Introduced by an XML start-tag such as
C<E<lt>fooE<gt>>. Inside a quasi, Links code enclosed within braces 
{ } will be evaluated to an XML forest and include, when the quasi 
is evaluated.

    <html>
      <ul>
        <li> First item: {item1} </li>
        <li> Second item: {item2} </li>
      </ul>
    </html>

Within an XML quasi, a variety of special features can be used to
handle browser events. See L<Handling Browser Events>, below, for more
information on these features.

=head2 Comparisons and Boolean Expressions

Comparisons are binary operations that yield a true/false value. 

=over 4

=item * ==

True iff the operands evaluate to the same value.

=item * <>

True iff the operands evaluate to different values.

=item * <<

True iff the left operand's value is less than the right operand's
(only valid on numbers (?))

=item * >>

True iff the right operand's value is less than the left operand's
(only valid on numbers (?))

=item * <=

True iff the left operand's value is less than or equal to the right
operand's (only valid on numbers (?))

=item * >=

True iff the right operand's value is less than or equal to the left
operand's (only valid on numbers (?))

=back

Boolean expressions can be combined using the boolean operators:

=over 4

=item * &&

=item * ||

=item * !

=back

=head2 Conditionals

A conditional expression has a condition, a consequent, and an else
clause. None of the three may be omitted.

    if (x == y)
        do_something()
    else
        do_something_else()

Curly braces can be wrapped either clause, no matter how many
sub-expressions they contain, and I<must> be so wrapped if you want
the clause to consist of more than one semicolon-separated expression.

Note that an C<if>-C<else> expression I<always> returns a value in
Links; the return values of the two branches must be of the same type,
and both branches are required.

=head2 Variables

Variables are single-assignment in Links. The form

    x = expr;
    etc

evaluates C<expr> and binds the name C<x> to the resulting value,
within the expression C<etc>.

Variable assignments have block scope. The following example

    x = 1;
    if (condition) {
      x = 2
    } else {
      x = 3
    };
    print int_to_string(x);

prints C<1> because the assignments to C<x> within the if clauses only
bind within those clauses. If you want the value printed to depend on
the condition, you should assign to C<x> from the result of the whole
C<if> expression:

    x = if (condition) {
      x = 2
    } else {
      x = 3
    };
    print int_to_string(x);

=head2 Blocks

A sequence of assignments separated by semicolons is evaluated in
turn, binding each value to the corresponding name in what
follows. Variables are assigned only once per scope, and succeeding
assignments will mask preceding ones:

    x = 1;
    y = 2;
    x = 2;
    z = x + y;    # z is now bound to 4

The scope of an assignment is strictly within its immediate block. As
a result, the following code may not do what you expect:

    x = 0;
    if (a == b)
        x = 1;
    else
        x = 2;
    alert(x);

The value printed by C<alert> will be 0. That's because the other two
assignments only create new bindings for x within the corresponding
clauses of the conditional. This may come as a surprise to programmers
from some languages.

=head2 Lists

A list is a finite sequence of values. A list can be created directly 
by wrapping a series of expressions in brackets:

    [1, 4, 9, 16]
    
    ["apple", "banana", "pear"]

    x = true;
    [true, false, x, true]

Note that all elements of a list must be of the same type.

Lists support the "concatenate" operation, denoted by two plus
characters:

    [1, 2] ++ [3, 4, 5] == [1, 2, 3, 4, 5]

And they're comparable, with C<==>, as you can see!

=head2 Functions

Functions can be named or anonymous. Named functions look like

    fun foo(x, y, z)
    {
        # ... body 
    }

Anonymous functions just omit the name: C<fun (x) { x + 1 }> is an
expression that evaluates to an anonymous function value.

Function values, whether named or anonymous, are lexical closures; any
variables free in the body must refer to bindings from a surrounding
lexical scope. The smallest surrounding scope is chosen.

A function can be called by using its name, followed by a list of
arguments in parentheses:

    foo(1, 2, 7)

This works whether C<foo> is a function defined with a name, as C<fun
foo(...) {...}>, or a variable bound to a functional value, as

    inc = fun (x) {x + 1};
    inc(7)

This block returns C<8>.

=head2 Loops (List Comprehensions)

The principal loop construct in Links is the list comprehension:

    for (x <- source)
       body

The body should be an expression that evaluates to a list.

The value of a comprehension is the concatenation of all the lists
produced by evaluating the body, once for each element of I<source>, and
binding that element to the variable C<x>. For example:

    source_list = [1, 2, 3];
    for (x <- source_list)
        [ x*x ]

constructs a list of the squares of the values in C<source_list>. Note
that more than one value can be included in the body list:

    source_list = [2, 3, 7, 8, 9, 55];
    for (n <- source_list)
        if (odd(n))
           [n, n+1]
        else
           [n]

This example returns C<[2, 3, 4, 7, 8, 8, 9, 10, 55, 56]>.

Other forms of looping can be implemented using tail recursion.

=head1 Features

=head2 Concurrency

A Links program begins as a single thread of control but can fork into
many threads by executing the C<spawn> primitive:

  newThreadID = spawn(func, arg)

This starts a new thread which begins by applying C<func> to the
single argument C<arg>. If the function ever returns, its return value
is discarded. C<spawn> returns an identifier of the new thread to the
calling thread. This identifier can be used to address messages to the
new thread, with the C<send> primitive:

  send(threadID, msg)

This appends the value C<msg> to the mailbox for the thread identified
by C<threadID>. The return value is just C<msg>. The mailbox is FIFO,
so if you know that some message is sent before some other message,
you know they will be received in that order.

Each process's mailbox is given a static type according to the
messages it expects to receive. Typically, a process will use variants
to tag the various messages it can receive; for example, a process
that can expects to be informed of passing comets and celebrity
sightings might expect to receive either a value
C<CelebritySighting(celebName, atVenue)> or a value
C<PassingComet(cometID, zenith, azimuth)>. This process's mailbox
would be given the type 
C<[|CelebritySighting(String, String) | PassingComet(Int, Float, Float)|]>

A process can receive messages using the C<recv> function, which
returns the next message in the current process's mailbox.

  nextMsg = recv()

More commonly, however, you will want to dispatch on the received
message's variant tag immediately. The C<receive> construct makes this
easy to do.

  receive {
    case CelebritySighting(celebName, atVenue) -> e1;
    case PassingComet(cometID, zenith, azimuth) -> e2;
  }

This removes the next message from the mailbox and does a C<switch> on
it. (See L<Variants>).

=head2 Located code and remote procedure calls

TBD: Describe client/server annotations and RPC calls

=head2 Handling User Actions

A Links program usually runs on a client (browser) and a server. The
client code can be notified when certain user events take place, such
as pressing a key on the keyboard or clicking on a hyperlink. The code
that responds to such events is associated with particular nodes in
the DOM tree and is expressed through special XML attributes, called
l-event attributes, attached to the relevant XHTML tags. This section
defines the attributes and their use.

An l-event attribute begins with the prefix C<l:> and corresponds to
an event type as defined by the browser. The event type is determined
by the attribute name simply by stripping off the C<l:>
prefix. Widely-supported l-event attributes include:

=over 4 

=item * C<l:onmousedown>

=item * C<l:onmouseup>

=item * C<l:onkeyup>

=item * C<l:onkeydown>

=item * C<l:onclick>

=item * C<l:onfocus>

=item * C<l:onchange>

=item * C<l:onload>

=back

When an element containing one of these attributes is installed in the
current DOM document (see L<Modifying the DOM>), the associated code
is registered as a handler for the corresponding event type. If the
element is removed from the DOM, its event handlers become inactive.

The content of one of these attributes should be a Links expression
enclosed in braces C<{E<nbsp>}>, an expression of type unit (?) which
may perform side-effects in response to the event. For example:

    <input type="button" value="Add Photo"
           l:onclick="{dom ! AppendChild({id = "container",
                                          node = <img src="..."/>})}" />


=head3 Interpreting the Event

A variable C<event> is always in scope for l-event code; the value of
this variable is a record corresponding to the event object passed by
the browser: it contains a field for each data member of the browser's
object. (TBD: give refs for IE, Mozilla docs) (NOTE: this is not
well-defined; need to use functional wrapper.)

=head2 Modifying the DOM

L<XML Quasiquote|XML Quasiquotes> expressions construct XML values;
but these values are not rendered by a browser until they are
I<installed> in the I<active document>.

There are two ways to modify the active document:

=over 4

=item 1.
A value returned by the final expression of a Links program is
installed as the (initial) active document.

=item 2.
Messages sent to the special process C<dom> can modify the active
document.

=back

Elements that are not installed are not visible, nor do events occur
on them, so their event handlers cannot fire.

=head2 Interacting with the page: DOM operations

Links enforces a distinction between XML trees, which are immutable,
and DOM nodes, which are mutable objects. DOM nodes are owned by a DOM
manager module, and all interaction with DOM nodes is through calls to
that module, using objects call C<DOMNodeRef>s. You can create DOM
nodes by passing an XML tree: the XML constitutes a model for the DOM
node, which is a rough copy of the XML. Likewise, from a DOMNodeRef,
you can extract an XML image of the DOM node and its DOM subtree. The
browser may have special semantics associated with DOM nodes, and may
add or remove attributes and children without warning; XML values,
however, are completely within the control of the Links program.

The operations on DOMNodeRefs are as follows:

=over 4

=item domInsertBeforeXml

=item domAppendChildXml

=item domRemoveNodeRef

=item domInsertBeforeRef

=item domAppendChildRef

=item domGetDocRef

=item domGetRefByID

=item domGetRepresentation

=back 

You can also access attributes of DOM nodes, and navigate the DOM
tree, in a reado-only fashion using the following operations:

=over 4 

=item domGetTagNameRef

=item domGetAttributeRef

=item domGetParentNodeRef

=back


=head1 Standard Library

TBD: other standard operations.

=cut

