fun all(p, l) { 
   switch (l) {
     case []    -> true
     case x::xs -> p(x) && all(p, xs)
   }
}

fun and(l) { 
   switch (l) {
     case [] -> true
     case x::xs -> x && and(xs)
   }
}

fun or(l) { 
   switch (l) {
     case [] -> false
     case x::xs -> x || or(xs)
   }
}

fun any(p, l) {
   switch (l) {
     case [] -> false
     case x::xs -> p(x) || any(p, xs)
   }
}

fun odd(i)  { i `mod` 2 == 1 }
fun even(i) { i `mod` 2 == 0 }

#fun null(l) { l == [] }

# return element i of xs
fun select(xs, i) {
  hd(drop(i, xs))
}

# swap all instances of x1 and x2 in xs
fun swap(xs, x1, x2) {
 for (var x <- xs) {
  if (x == x1) [x2]
  else if (x == x2) [x1]
  else [x]
 }
}

fun fold_left(p, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> fold_left(p, p(u, x), xs)
  }
}

fun fold_left1(p, l) {
  fold_left(p, hd(l), tl(l))
}

fun fold_right(f, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> f(x, fold_right(f,u,xs))
  }
}

fun fold_right1(f, l) {
  fold_right(f, hd(l), tl(l))
}

fun zip(l) {
  switch (l) {
    case [] -> ([], [])
    case (a,b)::xs -> { 
     var (c,d) = zip(xs);
     (a :: c, b :: d)
    }
  }
}

fun replicate(n, l) {
  if (n == 0) []
  else l :: replicate(n-1, l)
}

fun filter(p, l) {
  for (var x <- l) where (p(x)) [x]
}


fun flip(f) {
  fun(x,y) { f(y,x) }
}

fun curry(f) {
  fun (x)(y) { f(x,y) }
}

fun uncurry(f) {
  fun (x, y) { f(x)(y) }
}

fun compose(f, g) {
  fun (x) { f(g(x)) }
}

fun id(x) { x }

fun concatMap(f,l) {
  for (var x <- l) f(x)
}

fun first(p)   { p.1 }
fun second(p)  { p.2 }
fun third(p)   { p.3 }
fun fourth(p)  { p.4 }
fun fifth(p)   { p.5 }
fun sixth(p)   { p.6 }
fun seventh(p) { p.7 }
fun eighth(p)  { p.8 }
fun ninth(p)   { p.9 }
fun tenth(p)   { p.10 }

fun sum(ns) {
  fold_left(uncurry((+)), 0, ns)
}

fun product(ns) {
  fold_left(uncurry((*)), 1, ns)
}

fun map(f, l) {
  switch (l) {
    case []     -> []
    case hd::tl -> f(hd) :: map(f,tl)
  }
}

fun reverse(l) {
  fun aux(l,o) {
    switch (l) {
      case [] -> o
      case x::xs -> aux(xs, x::o)
    }
  }
  aux(l, [])
}


fun concat(list) {
  switch (list) {
    case [] -> []
    case (x::xs) -> x ++ concat(xs)
  }
}

fun join(glue,list) {
  switch (list) {
    case [] -> []
    case [x] -> x
    case (x::xs) -> x ++ glue ++ join(glue,xs)
  }
}

# break :: (a -> Bool) -> [a] -> ([a],[a])
# concat :: [[a]] -> [a]
# const :: const :: a -> b -> a
# dropWhile :: (a -> Bool) -> [a] -> [a]
# elemBy :: (a -> a -> Bool) -> a -> [a] -> Bool
# notElemBy :: (a -> a -> Bool) -> a -> [a] -> Bool
# span :: (a -> Bool) -> [a] -> ([a],[a])
# splitAt :: Int -> [a] -> ([a],[a])
# takeWhile :: (a -> Bool) -> [a] -> [a]
# until :: (a -> Bool) -> (a -> a) -> a -> a
# zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

# div :: Int -> Int -> Int
# gcd :: Int -> Int -> Int
# rem :: Int -> Int -> Int
# lcm :: Int -> Int -> Int
# subtract :: Int -> Int -> Int
# quot :: Int -> Int -> Int
# signum :: Int -> Int
# abs :: Int -> Int

# init :: [a] -> [a]
# last :: [a] -> a

# lines :: String -> [String]
# unlines :: [String] -> String
# unwords :: [String] -> String
# words :: String -> [String]

# ceiling :: Float -> Int
# cos :: Float -> Float
# exp :: Float -> Float
# floor :: Float -> Int
# fromInt :: Int -> Float
# log :: Float -> Float
# pi :: Float
# round :: Float -> Int
# signumFloat :: Float -> Int
# sin :: Float -> Float
# sqrt :: Float -> Float
# tan :: Float -> Float
# truncate :: Float -> Int
# (**.) :: Float -> Float -> Float
# (*.) :: Float -> Float -> Float
# (/.) :: Float -> Float -> Float
# (+.) :: Float -> Float -> Float
# (-.) :: Float -> Float -> Float
# (^.) :: Float -> Int -> Float
# (/=.) :: Float -> Float -> Bool
# (==.) :: Float -> Float -> Bool


# pi :: Float
# signumFloat :: Float -> Int
# round :: Float -> Int
# truncate :: Float -> Int


# options
typename Maybe (a) = [|Nothing | Just:a|];

sig isJust : Maybe (a) -> Bool
fun isJust(x) {
  switch (x) {
    case Just (x) -> true
    case Nothing -> false
  }
}


sig search : ((a) -> Bool, [a]) -> Maybe (a)
fun search(p,l) {
  switch (l) {
    case [] -> Nothing
    case x::xs -> if (p(x)) Just(x)
                  else search(p,xs)
  }
}

sig find : ((a) -> Bool, [a]) -> a
fun find(p,l) {
  switch (l) {
    case [] -> error("Not_found")
    case x::xs -> if (p(x)) x
                  else find(p,xs)
  }
}

sig fromJust : Maybe (a) -> a
fun fromJust(x) {
  switch (x) {
    case Just (x) -> x
    case Nothing -> error ("fromJust failed")
  }
}

# association lists
# TBD: memassoc is an old LISP word. Perhaps a more modern name would fit better?
sig memassoc : (a,[(a,b)]) -> Bool
fun memassoc(x,l) {
  switch (l) {
    case []    -> false
    case (k,v)::xs -> k == x || memassoc(x, xs)
  }
}

sig lookup : (a,[(a,b)]) -> Maybe (b)
fun lookup(x,l) {
  switch (l) {
    case [] -> Nothing
    case (a,b)::xs -> if (a == x) Just(b)
                      else lookup(x,xs)
  }
}

sig assoc : (String,[(String,b)]) -> b
fun assoc(x,l) {
  switch (l) {
    case []    -> error("Not found " ++ x)
    case (k,v)::xs -> if (k == x) v
                      else assoc(x, xs)
  }
}

sig assocAll : (String,[(String,b)]) -> [b]
fun assocAll(x,l) {
  switch (l) {
    case []    -> []
    case (k,v)::xs -> if (k == x) 
                        (v::assocAll(x,xs))
                      else
                        assocAll(x,xs)
  }
}

#### WEB-RELATED ####

# [freshResource] is a bit of magic that makes the subsequent actions a
# new resource.  That is, it redirects the user to a new URL for the
# continuation. If you call this immediately after doing a destructive
# action (e.g. database updates) then reloading and the back button 
# are made "safe": the visible URL does not refer to the action, but 
# only to what follows the freshResource call.
fun freshResource() {
  escape esc in {
    exit(redirect("?_cont=" ++ reifyK(esc)))
  }
}

# [sendSuspend] generates some XML, outputs it, and terminates. It
# passes to xmlf the continuation, which will resume at the place
# of the sendSuspend call. This continuation can be used in l:handler
# for example, to pass the form values through as the return value
# of sendSuspend.
fun sendSuspend(xmlf) {
  escape returnf in {
    exit(xmlf(returnf))
  }
}


#### FORMS ABSTRACTION ####
#### Ultimately needs to be moved to a different namespaced module

typename Env = [(String,String)];
typename Names = Int;
typename State (d,a) = [|State:(d) ->(a,d)|];
typename Collector (a) = Env -> a;
typename Form (a) = State (Names, (Xml,Collector(a)));
typename Combiner (a,b,c) = Collector (a) -> Collector (b) -> Collector (c);

infixr 0 $;
sig $ : (a -> b) -> a -> b
fun f $ x { f(x) }


# state monad
sig runState : State (a,c) -> (a) -> (c,a)
fun runState(State (s)) { s }

infixl 1 >>=;

sig >>= : State (d,a) -> (a -> State(d,b)) -> State (d,b)
fun (State (x)) >>= f {
   State (fun (s) { var (v,s_) = x (s); runState (f (v)) (s_) })
}

infixl 1 >>;

sig >> : State(a,b) -> State (a,c) -> State (a,c)
fun m >> k {
   m >>= fun (_) { k }
}

sig retern : (a) -> State (b,a)
fun retern(a) {
  State (fun (s) { (a,s)  })
}

sig get : State (d,d)
var get = State (fun (s) { (s,s) });

sig put :  (a) -> State(a,())
fun put(s) {
  State (fun (_) { ((), s) })
}


sig fmap : (a -> b) -> State (c,a) -> State (c,b)
fun fmap(f)(x) {
  x >>= (fun (x) { retern (f(x)) })
} 

sig pure : a -> Form(a)
fun pure(v) {
  retern([], fun (_) { v })
}

infixr 1 @@@;
sig @@@ : Form (a) -> Form (((a)-> b)) -> Form (b)
fun m @@@ k {
  m >>= fun((x,c)){
  k >>= fun((y,f)){
  retern((x++y, fun(e){ f(e)(c(e)) }))}}
}

sig xml : Xml -> Form (())
fun xml(x) { retern ( (x, fun (e) { () })) }

sig text : String -> Form (())
fun text(s) { xml(stringToXml(s)) }

sig plug : (Xml -> Xml) -> Form (a) -> Form (a)
fun f `plug` m {
  m >>= fun((x,v)){ retern((f(x),v)) }
}

sig makeName : Int -> String
fun makeName(i) { "input_" ++ intToString(i) }

sig nextName : State (Int,String)
var nextName = 
   get >>= fun (i) {
   var name = makeName(i);
   put (i+1) >>
   retern (name)};


# Types of input we need to handle:
#   text
#   password
#   checkbox
#   radio
#   submit
#   reset
#   file
#   hidden
#   image
#   button

# A one element form can be constructed using the input function.
sig input : Form (String)
var input = 
   nextName >>= fun (name) {
   (retern (<input name="{name}"/>,
            fun (env) { assoc(name, env)}))};

# A one element form with an initial value
sig inputValue : String -> Form (String)
fun inputValue(v) { 
   nextName >>= fun (name) {
   (retern (<input name="{name}" value="{v}"/>,
            fun (env) { assoc(name, env)}))}
}

# A hidden form element
sig hidden : String -> Form (String)
fun hidden(v) { 
   nextName >>= fun (name) {
   (retern (<input name="{name}" value="{v}" type="hidden" />,
            fun (env) { assoc(name, env)}))}
}


# A file
sig inputFile : Form (String)
var inputFile = 
   nextName >>= fun (name) {
   (retern (<input name="{name}" type="file" />,
            fun (env) { assoc(name, env)}))};

# A form is rendered to Xml, and a handler applied, using the render function
sig render : ((a) -> Xml) -> Form (a) -> Xml
fun render(continuation)(frm) {
   var ((xml, extractor),_) = runState(frm)(0);
   <form enctype="application/x-www-form-urlencoded" l:onsubmit="{continuation(extractor(environment()))}" method="POST">
     {xml}
   </form>

}

# Render a multipart form
sig renderMultipart : ((a) -> Xml) -> Form (a) -> Xml
fun renderMultipart(continuation)(frm) {
   var ((xml, extractor),_) = runState(frm)(0);
   <form enctype="multipart/form-data" l:onsubmit="{continuation(extractor(environment()))}" method="POST">
     {xml}
   </form>

}


#sig forms : ([Form (a)]) -> Form ([a])
fun forms(fs) { 
  switch (fs) {
    case [] -> pure ([])
    case (x::xs) -> x @@@ (forms(xs) @@@ pure (fun(ls)(l) { l::ls}))
  }
}

sig inputInt : Form(Int)
var inputInt = input @@@ pure(stringToInt);

sig textarea : String -> Form (String)
fun textarea(value) {
   nextName >>= fun (name) {
    retern (<textarea name="{name}">{stringToXml(value)}</textarea>,
            fun (env) { assoc(name, env) })}
}

sig button : (String,[|Submit|Reset|Button|],a) -> Form (Maybe(a))
fun button(text, behaviour, v) {
  nextName >>= fun (name) {
    var behaviour = switch (behaviour) {
      case Submit -> "submit"
      case Reset -> "reset"
      case Button -> "button"
    };
    retern (<button name="{name}" value="here" type="{behaviour}">{stringToXml(text)}</button>,
            fun (env) { if (memassoc(name, env))  Just(v) else Nothing })
  }
}

sig submitButton : (String,a) -> Form (Maybe(a))
fun submitButton(text, v) {
  button(text, Submit, v)
}

sig resetButton : (String,a) -> Form (Maybe(a))
fun resetButton(text, v) {
  button(text, Reset, v)
}

sig pushButton : (String,a) -> Form (Maybe(a))
fun pushButton(text, v) {
  button(text, Button, v)
}

sig checkbox : Form (Bool)
var checkbox =
  nextName >>= fun (name) {
  retern (<input type="checkbox" name="{name}" value="yes" />,
          fun (env) { (memassoc(name, env)) })};


# before ++ [selected] ++ after is a list of (value, data) pairs
# layout is a function for rendering a list of (radio button, data) pairs
#
# [NOTE]
#   A default selection is compulsory as recommended by the HTML spec.
#   We should probably do the same for 'choice' (drop-down menus) as well.
#
# It is the users responsibility to ensure that layout produces Xml that
# uses each radio button exactly once and does not introduce any other input
# elements.
#
# The data components are useful for attaching extra data such as labels to
# the radio buttons.
sig inputRadiogroup : ([(String, a)], (String, a), [(String,a)], [(Xml, a)] -> Xml) -> Form (String) 
fun inputRadiogroup(before, selected, after, layout) {
  nextName >>= fun (name) {
    var before = for (var (value, data) <- before)
                  [(<input type="radio" name="{name}" value="{value}" />, data)];
    var selected = [(<input type="radio" checked="on" name="{name}" value="{selected.1}" />, selected.2)];
    var after = for (var (value, data) <- after)
                  [(<input type="radio" name="{name}" value="{value}" />, data)];
    
    retern (layout(before ++ selected ++ after), fun (env) { (assoc(name, env))})
  }
}


sig option : (a,String) -> State(Names,(Xml, (((String) -> [a]) -> String -> [a])))
fun option ((a,b)) {
   nextName >>= fun (name) {
   retern (<option value="{name}">{stringToXml(b)}</option>,
           (fun (k) (key) { if (key == name) a::k(key) else k(key) }))
}}


sig options : [(a,String)] -> State(Names,(Xml, (String) -> [a]))
fun options(items) {
  switch (items) {
     case [] -> retern (<#/>, fun (_) { [] })
     case item::items -> option(item) >>= fun (xml, r1) {
                         options(items) >>= fun (morexml, r2) {
                         retern (xml ++ morexml, r1(r2))}}
  }
}

sig choice : [(a,String)] -> Form (a)
fun choice (items) {
  nextName >>= fun (name) {
     options(items) >>= fun (xml, retrieve) {
        retern (<select name="{name}">{xml}</select>,
                fun (env) { hd(retrieve(assoc(name, env))) })
     }
  }
}

sig choices : [(a,String)] -> Form ([a])
fun choices (items) {
  nextName >>= fun (name) {
     options(items) >>= fun (xml, retrieve) {
        retern (<select name="{name}" multiple="multiple">{xml}</select>,
                fun (env) { concat(map(retrieve, assocAll(name,env))) })

     }
  }
}
