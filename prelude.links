fun all(p, l) {
   switch (l) {
     case []    -> true
     case x::xs -> p(x) && all(p, xs)
   }
}

fun and(l) { 
   switch (l) {
     case [] -> true
     case x::xs -> x && and(xs)
   }
}

fun or(l) { 
   switch (l) {
     case [] -> false
     case x::xs -> x || or(xs)
   }
}

fun any(p, l) {
   switch (l) {
     case [] -> false
     case x::xs -> p(x) || any(p, xs)
   }
}

fun the(l) {
  var x = hd(l);
  if (all(fun (y) { x == y }, l))
    x
  else
    error("list argument to 'the' had varying values.")
}

fun elem(x, l) {
  not(l==[]) && (x == hd(l) || x `elem` tl(l))
}

fun odd(i)  { i `mod` 2 == 1 }
fun even(i) { i `mod` 2 == 0 }

#fun null(l) { l == [] }

# return element at index i of xs
fun select(xs, i) {
  hd(drop(i, xs))
}

# infix operator for 'select'
op xs !! n { select(xs, n) }

# swap all instances of x1 and x2 in xs
fun swap(xs, x1, x2) {
 for (var x <- xs) {
  if (x == x1) [x2]
  else if (x == x2) [x1]
  else [x]
 }
}

fun fold_left(p, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> fold_left(p, p(u, x), xs)
  }
}

fun fold_left1(p, l) {
  fold_left(p, hd(l), tl(l))
}

fun fold_right(f, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> f(x, fold_right(f,u,xs))
  }
}

fun fold_right1(f, l) {
  fold_right(f, hd(l), tl(l))
}

fun unzip(l) {
  switch (l) {
    case [] -> ([], [])
    case (a,b)::xs -> { 
     var (c,d) = unzip(xs);
     (a :: c, b :: d)
    }
  }
}

fun zip(l, r) {
  switch ((l, r)) {
    case ([], []) -> []
    case (lh::lt, rh::rt) -> 
        (lh, rh) :: zip (lt, rt)
    case (_, _) -> []
  }
}

fun replicate(n, item) {
  if (n == 0) []
  else item :: replicate(n-1, item)
}

fun filter(p, l) {
  for (var x <- l) where (p(x)) [x]
}

fun flip(f) {
  fun(x,y) { f(y,x) }
}

fun curry(f) {
  fun (x)(y) { f(x,y) }
}

fun uncurry(f) {
  fun (x, y) { f(x)(y) }
}

fun compose(f, g) {
  fun (x) { f(g(x)) }
}

fun id(x) { x }

fun concatMap(f,l) {
  for (var x <- l) f(x)
}

fun first(p)   { p.1 }
fun second(p)  { p.2 }
fun third(p)   { p.3 }
fun fourth(p)  { p.4 }
fun fifth(p)   { p.5 }
fun sixth(p)   { p.6 }
fun seventh(p) { p.7 }
fun eighth(p)  { p.8 }
fun ninth(p)   { p.9 }
fun tenth(p)   { p.10 }

fun sum(ns) {
  fold_left((+), 0, ns)
}

fun product(ns) {
  fold_left((*), 1, ns)
}

fun map(f, l) {
  switch (l) {
    case []     -> []
    case hd::tl -> f(hd) :: map(f,tl)
  }
}

fun mapi(f, xs) {
  fun mi(i, xs) {
    switch (xs) {
      case []    -> []
      case x::xs -> f(x, i) :: mi(i+1, xs)
    }
  }
  mi(0, xs)
}

sig substAt : ([a], Int, a) -> [a]
fun substAt(xs, i, y) {
  switch (xs) {
    case [] -> []
    case x::xs -> if (i <= 0) {y :: xs}
                  else {x :: substAt(xs, i-1, y)}
  }
} 

fun reverse(l) {
  fun aux(l,o) {
    switch (l) {
      case [] -> o
      case x::xs -> aux(xs, x::o)
    }
  }
  aux(l, [])
}


fun concat(list) {
  switch (list) {
    case [] -> []
    case (x::xs) -> x ++ concat(xs)
  }
}

fun join(glue,list) {
  switch (list) {
    case [] -> []
    case [x] -> x
    case (x::xs) -> x ++ glue ++ join(glue,xs)
  }
}

# break :: ((a) -> Bool) -> ([a]) -> ([a],[a])
# concat :: [[a]] -> [a]
# const :: const :: (a) -> b -> a
# elemBy :: ((a) -> (a) -> Bool) -> (a) -> ([a]) -> Bool
# notElemBy :: ((a) -> (a) -> Bool) -> (a) -> ([a]) -> Bool
# span :: ((a) -> Bool) -> ([a]) -> ([a],[a])
# splitAt :: Int -> ([a]) -> ([a],[a])

sig takeWhile : ((a) -> Bool, [a]) -> [a]
fun takeWhile(pred, list) {
  switch (list) {
    case [] -> []
    case (h::t) -> 
      switch (pred(h)) {
        case true -> h :: takeWhile(pred, t)
        case false -> []
      }
  }
}

sig dropWhile : ((a) -> Bool, [a]) -> [a]
fun dropWhile(pred, list) {
  switch (list) {
    case [] -> []
    case (h::t) -> 
      switch (pred(h)) {
        case true -> dropWhile(pred, t)
        case false -> list
      }
  }
}

sig ignore : (a) -> ()
fun ignore (_) { }

# until :: ((a) -> Bool) -> ((a) -> a) -> (a) -> a
# zipWith :: ((a) -> b -> c) -> ([a]) -> [b] -> [c]

# div :: Int -> Int -> Int
# gcd :: Int -> Int -> Int
# rem :: Int -> Int -> Int
# lcm :: Int -> Int -> Int
# subtract :: Int -> Int -> Int
# quot :: Int -> Int -> Int

sig signum : (Int) -> Int
fun signum(i) {
  if (i>0) 1
  else if (i < 0) -1
  else 0
}

#sig abs : (Int) -> Int
#fun abs(i) {
#  if (i < 0) -i else i
#}

sig init : ([a]) -> [a]
fun init(list) {
  switch (list) {
    case [y] -> []
    case (h::t) -> h::init(t)
  }
}

fun curtail(list) { init(list) }

sig last : ([a]) -> a
fun last(list) {
  switch (list) {
    case [x] -> x
    case (h::t) -> last(t)
  }
}

# lines :: String -> [String]
# unlines :: [String] -> String
# unwords :: [String] -> String
# words :: String -> [String]

### Defined internally to Links:
# ceiling :: Float -> Int
# floor :: Float -> Int
# cos :: Float -> Float
# log :: Float -> Float
# sin :: Float -> Float
# sqrt :: Float -> Float
# tan :: Float -> Float
# (*.) :: Float -> Float -> Float
# (/.) :: Float -> Float -> Float
# (+.) :: Float -> Float -> Float
# (-.) :: Float -> Float -> Float
# (^.) :: Float -> Int -> Float
# (/=.) :: Float -> Float -> Bool
# (==.) :: Float -> Float -> Bool

# (**.) :: Float -> Float -> Float
# exp :: Float -> Float
# pi :: Float
# signumFloat :: Float -> Int
# round :: Float -> Int
# truncate :: Float -> Int

# Option types
typename Maybe (a) = [|Nothing | Just:a|];

sig isJust : (Maybe (a)) -> Bool
fun isJust(x) {
  switch (x) {
    case Just (x) -> true
    case Nothing -> false
  }
}


sig search : ((a) -> Bool, [a]) -> Maybe (a)
fun search(p,l) {
  switch (l) {
    case [] -> Nothing
    case x::xs -> if (p(x)) Just(x)
                  else search(p,xs)
  }
}

sig find : ((a) -> Bool, [a]) -> a
fun find(p,l) {
  switch (l) {
    case [] -> error("Not_found")
    case x::xs -> if (p(x)) x
                  else find(p,xs)
  }
}

sig fromJust : (Maybe (a)) -> a
fun fromJust(x) {
  switch (x) {
    case Just (x) -> x
    case Nothing -> error ("fromJust failed")
  }
}

sig fromMaybe : (Maybe (a), a) -> a
fun fromMaybe(x, y) {
  switch (x) {
    case Just (x) -> x
    case Nothing -> y
  }
}


# association lists
# TBD: memassoc is an old LISP word. Perhaps a more modern name would fit better?
sig memassoc : (a,[(a,b)]) -> Bool
fun memassoc(x,l) {
  switch (l) {
    case []    -> false
    case (k,v)::xs -> k == x || memassoc(x, xs)
  }
}

sig lookup : (a,[(a,b)]) -> Maybe (b)
fun lookup(x,l) {
  switch (l) {
    case [] -> Nothing
    case (a,b)::xs -> if (a == x) Just(b)
                      else lookup(x,xs)
  }
}

sig assoc : (String,[(String,b)]) -> b
fun assoc(x,l) {
  switch (l) {
    case []    -> error("Not found " ++ x)
    case (k,v)::xs -> if (k == x) v
                      else assoc(x, xs)
  }
}

sig removeAssoc : (a,[(a,b)]) -> [(a,b)]
fun removeAssoc(x,l) {
  switch (l) {
    case [] -> []
    case (k,v)::xs -> if(k == x) xs
                      else (k,v)::removeAssoc(x, xs) 
  }
}

sig assocAll : (String,[(String,b)]) -> [b]
fun assocAll(x,l) {
  switch (l) {
    case []    -> []
    case (k,v)::xs -> if (k == x) 
                        (v::assocAll(x,xs))
                      else
                        assocAll(x,xs)
  }
}

# TBD: rename this 'sortOn' to follow Haskell usage?
sig sortBy : ((a) -> b, [a]) -> [a]
fun sortBy (f, l) {
  switch (l) {
    case [] -> []
    case x::xs -> {
      var lt = for (var y <- xs) where (f(y) < f(x))  [y];
      var ge = for (var y <- xs) where (f(y) >= f(x)) [y];
      sortBy(f, lt) ++ [x] ++ sortBy(f, ge)
    }
  }
}

sig isInt : (String) -> Bool
fun isInt (x) { x ~ /-?[0-9]+$/ }

sig isFloat : (String) -> Bool
fun isFloat (x) { x ~ /-?[0-9]+(\.[0-9]+)?$/ }
