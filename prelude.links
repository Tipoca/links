fun all(p, l) { 
   switch (l) {
     case []    -> true
     case x::xs -> p(x) && all(p, xs)
   }
}

fun and(l) { 
   switch (l) {
     case [] -> true
     case x::xs -> x && and(xs)
   }
}

fun or(l) { 
   switch (l) {
     case [] -> false
     case x::xs -> x || or(xs)
   }
}

fun any(p, l) {
   switch (l) {
     case [] -> false
     case x::xs -> p(x) || any(p, xs)
   }
}

fun odd(i)  { mod(i)(2) == 1 }
fun even(i) { mod(i)(2) == 0 }

fun null(l) { l == [] }

fun fold_left(p, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> fold_left(p, p(u, x), xs)
  }
}

fun fold_left1(p, l) {
  fold_left(p, hd(l), tl(l))
}

fun fold_right(f, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> f(x, fold_right(f,u,xs))
  }
}

fun fold_right1(f, l) {
  fold_right(f, hd(l), tl(l))
}

fun zip(l) {
  switch (l) {
    case [] -> ([], [])
    case (a,b)::xs -> { 
     var (c,d) = zip(xs);
     (a :: c, b :: d)
    }
  }
}

fun replicate(n, l) {
  if (n == 0) []
  else l :: replicate(n-1, l)
}

fun filter(p, l) {
  for (var x <- l) where (p(x)) [x]
}


fun flip(f) {
  fun(x,y) { f(y,x) }
}

fun curry(f) {
  fun (x)(y) { f(x,y) }
}

fun uncurry(f) {
  fun (x, y) { f(x)(y) }
}

fun compose(f, g) {
  fun (x) { f(g(x)) }
}

fun id(x) { x }

fun concatMap(f,l) {
  for (var x <- l) f(x)
}

fun first(p)   { p.1 }
fun second(p)  { p.2 }
fun third(p)   { p.3 }
fun fourth(p)  { p.4 }
fun fifth(p)   { p.5 }
fun sixth(p)   { p.6 }
fun seventh(p) { p.7 }
fun eighth(p)  { p.8 }
fun ninth(p)   { p.9 }
fun tenth(p)   { p.10 }

fun sum(ns) {
  fold_left(uncurry((+)), 0, ns)
}

fun product(ns) {
  fold_left(uncurry((*)), 1, ns)
}

fun map(f, l) {
  switch (l) {
    case []     -> []
    case hd::tl -> f(hd) :: map(f,tl)
  }
}

fun reverse(l) {
  fun aux(l,o) {
    switch (l) {
      case [] -> o
      case x::xs -> aux(xs, x::o)
    }
  }
  aux(l, [])
}


fun concat(list) {
  switch (list) {
    case [] -> []
    case (x::xs) -> x ++ concat(xs)
  }
}

fun join(glue,list) {
  switch (list) {
    case [] -> []
    case [x] -> x
    case (x::xs) -> x ++ glue ++ concat(xs)
  }
}

# break :: (a -> Bool) -> [a] -> ([a],[a])
# concat :: [[a]] -> [a]
# const :: const :: a -> b -> a
# dropWhile :: (a -> Bool) -> [a] -> [a]
# elemBy :: (a -> a -> Bool) -> a -> [a] -> Bool
# notElemBy :: (a -> a -> Bool) -> a -> [a] -> Bool
# span :: (a -> Bool) -> [a] -> ([a],[a])
# splitAt :: Int -> [a] -> ([a],[a])
# takeWhile :: (a -> Bool) -> [a] -> [a]
# until :: (a -> Bool) -> (a -> a) -> a -> a
# zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

# div :: Int -> Int -> Int
# gcd :: Int -> Int -> Int
# rem :: Int -> Int -> Int
# lcm :: Int -> Int -> Int
# subtract :: Int -> Int -> Int
# quot :: Int -> Int -> Int
# signum :: Int -> Int
# abs :: Int -> Int

# init :: [a] -> [a]
# last :: [a] -> a

# lines :: String -> [String]
# unlines :: [String] -> String
# unwords :: [String] -> String
# words :: String -> [String]

# ceiling :: Float -> Int
# cos :: Float -> Float
# exp :: Float -> Float
# floor :: Float -> Int
# fromInt :: Int -> Float
# log :: Float -> Float
# pi :: Float
# round :: Float -> Int
# signumFloat :: Float -> Int
# sin :: Float -> Float
# sqrt :: Float -> Float
# tan :: Float -> Float
# truncate :: Float -> Int
# (**.) :: Float -> Float -> Float
# (*.) :: Float -> Float -> Float
# (/.) :: Float -> Float -> Float
# (+.) :: Float -> Float -> Float
# (-.) :: Float -> Float -> Float
# (^.) :: Float -> Int -> Float
# (/=.) :: Float -> Float -> Bool
# (==.) :: Float -> Float -> Bool


# pi :: Float
# signumFloat :: Float -> Int
# round :: Float -> Int
# truncate :: Float -> Int

#### FORMS ABSTRACTION ####
#### Ultimately needs to be moved to a different namespaced module

# State a ===  [|State:(d) -> (a,d)|]
# Form a == State Names (Xml, Collector a)
# Collector a == Env -> a
# Combiner a b c == Collector a -> Collector b -> Collector c

infixr 0 $;
fun f $ x { f(x) }

fun lookup(x,l) {
  switch (l) {
    case []    -> error("Not found " ++ x)
    case (k,v)::xs -> if (k == x) v
                      else lookup(x,xs)
  }
}

fun lookupAll(x,l) {
  switch (l) {
    case []    -> []
    case (k,v)::xs -> if (k == x) 
                        (v::lookupAll(x,xs))
                      else
                        lookupAll(x,xs)
  }
}

# TBD: memassoc is an old LISP word. Perhaps a more modern name would fit better?
fun memassoc(x,l) {
  switch (l) {
    case []    -> false
    case (k,v)::xs -> k == x || memassoc(x, xs)
  }
}

fun repeat(n)(x) {
   if (n == 0) []
   else x :: repeat(n-1)(x)
}

# state monad
fun runState(State (s)) { s : ((s) -> (a,s)) }

infixl 1 >>=;
infixl 1 >>;

fun (State (x)) >>= f {
   State (fun (s) { var (v,s_) = x (s); runState (f (v)) (s_) })
}

sig return : (a) -> [|State:(d) -> (a, d)|]
fun return(a) {
  State (fun (s) { (a,s)  })
}

var get = State (fun (s) { (s,s) });

sig put :  (a) -> [|State:(a) -> ((), a)|] # ?
fun put(s) {
  State (fun (_) { ((), s) })
}

fun m >> k {
   m >>= fun (_) { k }
}

fun fmap(f)(x) {
  x >>= (fun (x) { return (f(x)) })
} 

# pure : a -> Form(a)
fun pure(v) {
  return([], fun (_) { v })
}

# (@@@) : Form(a) -> Form(a->b) -> Form(b)
infixr 1 @@@;
fun m @@@ k {
  m >>= fun((x,c)){
  k >>= fun((y,f)){
  return((x++y, fun(e){ f(e)(c(e)) }))}}
}

# xml : Xml -> Form(())
fun xml(x) { return ( (x, fun (e) { () })) }

# text : String -> Form(())
fun text(s) { xml(stringToXml(s)) }

# plug : (Xml -> Xml) -> Form(a) -> Form(a)
fun f `plug` m {
  m >>= fun((x,v)){ return((f(x),v)) }
}

fun makeName(i : Int) { "input_" ++ intToString(i) }
var nextName = 
   get >>= fun (i) {
   var name = makeName(i);
   put (i+1) >>
   return (name)};

# A one element form can be constructed using the input function.
var input = 
   nextName >>= fun (name) {
   (return (<input name="{name}"/>,
            fun (env) { lookup(name, env)}))};


# A form is rendered to Xml, and a handler applied, using the render function
fun render(continuation)(frm) {
   var ((xml, extractor),_) = runState(frm)(0);
   <form l:onsubmit="{continuation(extractor(environment()))}" method="POST">{xml}
    <input type="submit"/>
   </form>

}


# inputInt : Form(Int)
var inputInt = input @@@ pure(stringToInt);

fun inputSelect(items) {
   nextName >>= fun (name) {
   (return (<select name="{name}">
              { for (var (text, id) <- items) 
                  <option value="{intToString(id)}">{stringToXml(text)}</option>
              }
            </select>,
            fun (env) { stringToInt(lookup(name, env))}))}
}

fun inputText(value) {
   nextName >>= fun (name) {
    return (<textarea name="{name}">{stringToXml(value)}</textarea>,
            fun (env) { lookup(name, env) })}
}

fun inputButton(value) {
   nextName >>= fun (name) {
    return (<button name="{name}" value="{value}" >{stringToXml(value)}</button>,
            fun (env) { memassoc(name, env) })}
}

fun inputSelectMultiple(items) {
   nextName >>= fun (name) {
   (return (<select multiple="multiple" name="{name}">
              { for (var (text, id) <- items) 
                  <option value="{intToString(id)}">{stringToXml(text)}</option>
              }
            </select>,
            fun (env) { map(stringToInt,lookupAll(name, env))}))}
}

fun inputCheckbox() {
   nextName >>= fun (name) {
    return (<input type="checkbox" name="{name}" value="yes" />,
            fun (env) { (memassoc(name, env)) })}
}

fun inputRadiogroup(items) {
}

()
